"use strict";
var _ = require('lodash');
var tree_types_1 = require('./tree.types');
var Tree = (function () {
    function Tree(node, parent, isBranch) {
        if (parent === void 0) { parent = null; }
        if (isBranch === void 0) { isBranch = false; }
        this.node = node;
        this.parent = parent;
        this._children = isBranch ? [] : null;
    }
    Object.defineProperty(Tree.prototype, "children", {
        get: function () {
            return this._children;
        },
        enumerable: true,
        configurable: true
    });
    Tree.prototype.createNode = function (isBranch) {
        var tree = new Tree({ value: '' }, null, isBranch);
        tree.markAsNew();
        if (this.isLeaf()) {
            return this.addSibling(tree);
        }
        else {
            return this.addChild(tree);
        }
    };
    ;
    Object.defineProperty(Tree.prototype, "value", {
        get: function () {
            return this.node.value;
        },
        set: function (value) {
            if (typeof value !== 'string' && !Tree.isRenamable(value)) {
                return;
            }
            if (Tree.isRenamable(this.value)) {
                var newValue = typeof value === 'string' ? value : _.toString(value);
                this.node.value = Tree.applyNewValueToRenamable(this.value, newValue);
            }
            else {
                this.node.value = Tree.isValueEmpty(value) ? this.node.value : _.toString(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Tree.prototype.addSibling = function (sibling, position) {
        if (_.isArray(_.get(this.parent, 'children'))) {
            return this.parent.addChild(sibling, position);
        }
        return null;
    };
    Tree.prototype.addChild = function (child, position) {
        return this._addChild(Tree.cloneTreeShallow(child), position);
    };
    Tree.prototype._addChild = function (child, position) {
        if (position === void 0) { position = _.size(this._children) || 0; }
        child.parent = this;
        if (Array.isArray(this._children)) {
            this._children.splice(position, 0, child);
        }
        else {
            this._children = [child];
        }
        return child;
    };
    Tree.prototype.swapWithSibling = function (sibling) {
        if (!this.hasSibling(sibling)) {
            return;
        }
        var siblingIndex = sibling.positionInParent;
        var thisTreeIndex = this.positionInParent;
        this.parent._children[siblingIndex] = this;
        this.parent._children[thisTreeIndex] = sibling;
    };
    Object.defineProperty(Tree.prototype, "positionInParent", {
        get: function () {
            return _.indexOf(this.parent.children, this);
        },
        enumerable: true,
        configurable: true
    });
    Tree.prototype.isStatic = function () {
        return _.get(this.node.settings, 'static', false);
    };
    Tree.prototype.isLeaf = function () {
        return !this.isBranch();
    };
    Tree.prototype.isBranch = function () {
        return Array.isArray(this._children);
    };
    Tree.prototype.isRoot = function () {
        return this.parent === null;
    };
    Tree.prototype.hasSibling = function (tree) {
        return !this.isRoot() && _.includes(this.parent.children, tree);
    };
    Tree.prototype.hasChild = function (tree) {
        return _.includes(this._children, tree);
    };
    Tree.prototype.removeChild = function (tree) {
        var childIndex = _.findIndex(this._children, function (child) { return child === tree; });
        if (childIndex >= 0) {
            this._children.splice(childIndex, 1);
        }
    };
    Tree.prototype.removeItselfFromParent = function () {
        if (!this.parent) {
            return;
        }
        this.parent.removeChild(this);
    };
    Tree.prototype.switchFoldingType = function () {
        if (this.isLeaf()) {
            return;
        }
        this.node._foldingType = this.isNodeExpanded() ? tree_types_1.FoldingType.Collapsed : tree_types_1.FoldingType.Expanded;
    };
    Tree.prototype.isNodeExpanded = function () {
        return this.foldingType === tree_types_1.FoldingType.Expanded;
    };
    Object.defineProperty(Tree.prototype, "foldingType", {
        get: function () {
            if (!this.node._foldingType) {
                if (this._children) {
                    this.node._foldingType = tree_types_1.FoldingType.Expanded;
                }
                else {
                    this.node._foldingType = tree_types_1.FoldingType.Leaf;
                }
            }
            return this.node._foldingType;
        },
        enumerable: true,
        configurable: true
    });
    Tree.prototype.isNew = function () {
        return this.node._status === tree_types_1.TreeStatus.New;
    };
    Tree.prototype.markAsNew = function () {
        this.node._status = tree_types_1.TreeStatus.New;
    };
    Tree.prototype.isBeingRenamed = function () {
        return this.node._status === tree_types_1.TreeStatus.IsBeingRenamed;
    };
    Tree.prototype.markAsBeingRenamed = function () {
        this.node._status = tree_types_1.TreeStatus.IsBeingRenamed;
    };
    Tree.prototype.isModified = function () {
        return this.node._status === tree_types_1.TreeStatus.Modified;
    };
    Tree.prototype.markAsModified = function () {
        this.node._status = tree_types_1.TreeStatus.Modified;
    };
    Tree.buildTreeFromModel = function (model, parent) {
        if (parent === void 0) { parent = null; }
        model.settings = tree_types_1.TreeModelSettings.merge(model, _.get(parent, 'node'));
        var tree = new Tree(_.omit(model, 'children'), parent);
        _.forEach(model.children, function (child, index) {
            tree._addChild(Tree.buildTreeFromModel(child, tree), index);
        });
        return tree;
    };
    Tree.isValueEmpty = function (value) {
        return _.isEmpty(_.trim(value));
    };
    Tree.isRenamable = function (value) {
        return (_.has(value, 'setName') && _.isFunction(value.setName))
            && (_.has(value, 'toString') && _.isFunction(value.toString) && value.toString !== Object.toString);
    };
    Tree.cloneTreeShallow = function (origin) {
        var tree = new Tree(_.clone(origin.node));
        tree._children = origin._children;
        return tree;
    };
    ;
    Tree.applyNewValueToRenamable = function (value, newValue) {
        var renamableValue = _.merge({}, value);
        renamableValue.setName(newValue);
        return renamableValue;
    };
    return Tree;
}());
exports.Tree = Tree;
//# sourceMappingURL=tree.js.map